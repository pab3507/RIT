// Document Analysis project functions

#include <stdlib.h>
#include <stdio.h>

#include <string.h>
#include "analysis.h"
#include "unit_tests.h"

// Define your linked list here. It should be prefixed with static so it is only accessible
// from inside this module.
// Also, you will need to maintain the current location in the doubly linked list to support the next and previous functions.
struct node *p-head = NULL;

	struct node
	{
		struct word-entry entry;
		struct node *p-next;
		struct node *p-prev;
	}

// returns 0 if the file cannot be read or if the file does not contain any words as defined for this project.
// returns 0 if the pointer to the file name is NULL.
// returns 1 if the file was found, opened successfully, and successfully read into the doubly linked list.
int read_file( char *file_name )
{
	if(file_name[0] == "\0"){
		return 0;
	}
	FILE* f = fopen(file_name);
	char buffer[MAX_WORD_LENGTH];
	while(fscanf(f, "%s", buffer) > 0){
		add(buffer);
	}
	// fill this in. You should create a doubly linked list and add entries to that list in this function.
	// This will be a significant effort. You should create your own functions to implement parts of this logic.
	// For the bonus you will need to add some significant logic to this function. DO NOT try the bonus until all else works.
	return 1 ;		// temporary code so it compiles and runs.
}

void add(char buffer[]){
	
}

// This walks through the linked list and frees every node in the linked list.
// After freeing all nodes in the list be sure to set your head and tail
// pointers to NULL to indicate that the list is now empty.
void free_list()
{
}

// Returns 0 in the word_count field if no first word (empty list).
// Otherwise, returns a struct with the first unique word and its number of occurrences in the text file.
struct word_entry get_first_word()
{
	struct word_entry one_word ;
	
	one_word.word_count = 0 ;
	
	return one_word ;
}

// Returns 0 in the word_count field if no next word (previously reached end of list or it is an empty list).
// Otherwise, returns a struct with the next unique word and its number of occurrences in the text file.
struct word_entry get_next_word()
{
	struct word_entry one_word ;
	
	one_word.word_count = 0 ;
	
	return one_word ;
}

// Returns 0 in the word_count field if no previous word (was already at beginning of the list or it is an empty list).
// Otherwise, returns a struct with the previous unique word and its number of occurrences in the text file.
struct word_entry get_prev_word()
{
	struct word_entry one_word ;
	
	one_word.word_count = 0 ;
	
	return one_word ;
}

// Returns 0 in the word_count field if it is an empty list).
// Otherwise, returns a struct with the last unique word and its number of occurrences in the text file.
struct word_entry get_last_word()
{
	struct word_entry one_word ;
	
	one_word.word_count = 0 ;
	
	return one_word ;
}

// Returns 0 if no sentences include an empty list and if there are no periods in the file.
// Otherwise returns number of sentences.
int get_sentence_count()
{
	return 0 ;		// temporary code so it compiles and links.
}

// returns 0 if word not found in the list.
// Searches the list for the word and returns its number of occurrences.
int get_unique_word_count( char *word_to_find )
{
	return 0 ;		// temporary code so it compiles and links.
}

// Returns a NULL pointer if word_to_find is not found in the list.
// Searches the list for word_to_find and returns the word that most commonly occurs after it.
// If word_to_find is ALWAYS the last word in the sentence it returns a pointer to an empty string.
char *get_most_common_word_after_this_word( char *word_to_find )
{
	return (char *)NULL ;	// temporary code that indicates that the word is not found.
}

// Writes the sorted unique word list to a csv file.
// Receives one parameter which is the name of the file to be created.
// Returns 1 on a successful write of the file.
// Returns 0 on any failure.
// Test for a NULL or empty string in the file_name. Return 0 for failure if NULL or empty.
// Be sure to test for failure to open the file, failure to write to the file, and failure to close.
// You must have a header row exactly like this (without the quotes): "word,count"
// You must have one row for each unique word and its count (e.g. without quotes "student,5").
// It must be in sorted order and must be the complete list.
int write_unique_word_list_to_csv_file( char *file_name )
{
	return 0 ;		// temporary code so it compiles and links.
}
